{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to My Technical Blog","text":"<p>Browse the latest articles below:</p>"},{"location":"#azure-ad","title":"Azure AD","text":"<ul> <li>Certificate Based Auth</li> </ul>"},{"location":"#sap","title":"SAP","text":"<ul> <li>Setup PyRFC in your Container</li> </ul> <p>Deploy to GitHub Pages directly: <pre><code>mkdocs gh-deploy --force\n</code></pre></p> <p>Run in local Dev Container: <pre><code>mkdocs serve --dev-addr=0.0.0.0:8000\n</code></pre></p>"},{"location":"azure-ad-certificate/","title":"Certificate-Based Authentication for Azure AD: Why and How","text":""},{"location":"azure-ad-certificate/#creating-a-certificate-for-azure-ad-authentication","title":"Creating a Certificate for Azure AD Authentication","text":"<p>To use certificate-based authentication with Azure Active Directory (Azure AD), you first need to generate a certificate. Certificates provide a secure, manageable, and standards-based way to authenticate applications. A <code>.pfx</code> certificate may be required because Azure AD expects a certificate in Personal Information Exchange (PFX) format when uploading via the portal or for certain SDKs. The <code>.pfx</code> file contains both the public and private keys, protected by a password, and is suitable for import/export scenarios.</p>"},{"location":"azure-ad-certificate/#steps-to-generate-a-certificate-using-openssl","title":"Steps to Generate a Certificate Using OpenSSL","text":"<ol> <li>Generate a Private Key: <pre><code>openssl genrsa -out my-app-auth.key 2048\n</code></pre></li> <li>Create a Certificate Signing Request (CSR): <pre><code>openssl req -new -key my-app-auth.key -out my-app-auth.csr\n</code></pre></li> <li>Generate a Self-Signed Certificate: <pre><code>openssl x509 -req -days 730 -in my-app-auth.csr -signkey my-app-auth.key -out my-app-auth.crt\n</code></pre></li> <li>Export to PFX (if needed for Azure): <pre><code>openssl pkcs12 -export -out my-app-auth.pfx -inkey my-app-auth.key -in my-app-auth.crt\n</code></pre> <p>Note: The <code>.pfx</code> format is required if you want to upload the certificate via the Azure Portal or use it with some SDKs/tools. The <code>.crt</code> file is the public certificate, and the <code>.key</code> file is your private key (keep it secure!).</p> </li> </ol>"},{"location":"azure-ad-certificate/#uploading-the-certificate-to-your-entra-azure-ad-application","title":"Uploading the Certificate to Your Entra (Azure AD) Application","text":"<ol> <li>Go to the Microsoft Entra admin center and select Azure Active Directory.</li> <li>Navigate to App registrations and select your application.</li> <li>In the left menu, click Certificates &amp; secrets.</li> <li>Under Certificates, click Upload certificate.</li> <li>Select your <code>.crt</code> or <code>.pfx</code> file and upload it.</li> <li>After uploading, Azure will display the certificate thumbprint. Save this value for use in your application code.</li> </ol>"},{"location":"azure-ad-certificate/#assigning-permissions-to-the-application","title":"Assigning Permissions to the Application","text":"<p>After uploading the certificate, you must assign the necessary API permissions to your application:</p> <ol> <li>In your application's App registration page, go to API permissions.</li> <li>Click Add a permission and select the required Microsoft APIs (e.g., Microsoft Graph, Azure Service Management, etc.).</li> <li>Choose the appropriate permission type (Application or Delegated) and select the required permissions.</li> <li>Click Add permissions.</li> <li>If required, click Grant admin consent to approve the permissions for your organization.</li> </ol> <p>Note: The application will only be able to access resources for which it has been granted permissions. Make sure to review and assign only the permissions your app needs.</p>"},{"location":"azure-ad-certificate/#why-use-a-certificate-instead-of-an-application-secret","title":"Why Use a Certificate Instead of an Application Secret?","text":""},{"location":"azure-ad-certificate/#1-security","title":"1. Security","text":"<ul> <li>Application secrets are essentially passwords. They are susceptible to accidental exposure (e.g., in code repositories, logs, or configuration files).</li> <li>Certificates use asymmetric cryptography. The private key never leaves your environment, and only the public key is uploaded to Azure AD. This makes certificates much harder to compromise.</li> </ul>"},{"location":"azure-ad-certificate/#2-lifecycle-management","title":"2. Lifecycle Management","text":"<ul> <li>Secrets typically expire every 6-12 months, requiring regular rotation and updates in all dependent systems.</li> <li>Certificates can have longer lifespans (e.g., 1-2 years), and their expiration is easier to track and automate.</li> </ul>"},{"location":"azure-ad-certificate/#3-compliance-and-best-practices","title":"3. Compliance and Best Practices","text":"<ul> <li>Microsoft and most security frameworks recommend certificates for service-to-service authentication.</li> <li>Certificates support better auditing and can be managed centrally (e.g., via Azure Key Vault).</li> </ul>"},{"location":"azure-ad-certificate/#why-use-the-msal-library-and-not-a-specific-azure-sdk","title":"Why Use the MSAL Library (and Not a Specific Azure SDK)?","text":"<p>The MSAL (Microsoft Authentication Library) for Python is a lightweight, flexible library for acquiring tokens from Azure AD. It supports a wide range of authentication scenarios, including certificate-based authentication for confidential clients.</p> <ul> <li>Why MSAL?</li> <li>MSAL is the official library for handling authentication and token acquisition with Azure AD.</li> <li>It is not tied to a specific Azure service, making it ideal for generic authentication scenarios.</li> <li> <p>It supports advanced scenarios like certificate-based authentication, multi-tenant apps, and more.</p> </li> <li> <p>Why Not Use a Specific Azure SDK?</p> </li> <li>Some Azure SDKs (e.g., for Storage, Key Vault, etc.) provide their own authentication mechanisms, but they may not support all advanced scenarios or may require additional dependencies.</li> <li>Using MSAL directly gives you full control over the authentication flow and token management, and is more transparent for troubleshooting and customization.</li> </ul>"},{"location":"azure-ad-certificate/#code-example-certificate-based-authentication-in-python","title":"Code Example: Certificate-Based Authentication in Python","text":"<p>Below is the function used in this project to acquire an Azure AD access token using a certificate:</p> <pre><code>from msal import ConfidentialClientApplication\n\ndef get_access_token_from_azure(client_id, authority, tenant_id, resource_scopes):\n    \"\"\"\n    Retrieves an access token from Azure Active Directory using a confidential client application.\n    This function uses certificate-based authentication to acquire an access token for the specified resource.\n    \"\"\"\n    try:\n        with open(f\"certs/{PFX_CERTIFICATE_NAME}.key\", \"r\") as key_file:\n            private_key = key_file.read()\n\n        app = ConfidentialClientApplication(\n            client_id=client_id,\n            authority=f\"{authority}{tenant_id}\",\n            client_credential={\n                \"thumbprint\": PFX_CERTIFICATE_NAME_TP,\n                \"private_key\": private_key,\n            },\n        )\n\n        result = app.acquire_token_for_client(scopes=resource_scopes)\n        if \"access_token\" in result:\n            return result[\"access_token\"]\n\n    except Exception as exception:\n        handle_global_exception(sys._getframe().f_code.co_name, exception)\n    finally:\n        pass\n</code></pre>"},{"location":"azure-ad-certificate/#key-points","title":"Key Points:","text":"<ul> <li>The private key is read from a secure file (<code>certs/*.key</code>).</li> <li>The certificate thumbprint and private key are passed to MSAL's <code>ConfidentialClientApplication</code>.</li> <li>No secrets or passwords are stored in code or configuration.</li> </ul>"},{"location":"azure-ad-certificate/#conclusion","title":"Conclusion","text":"<p>Certificate-based authentication is the recommended and most secure way to authenticate service applications with Azure AD. It reduces risk, simplifies management, and aligns with industry best practices. Migrating from secrets to certificates is straightforward and well-supported by both Azure and the MSAL Python library.</p>"},{"location":"azure-ad-certificate/#references","title":"References","text":"<ul> <li>MSAL Python Certificate Auth Sample</li> <li>Azure AD App Registration: Certificates &amp; Secrets</li> <li>OpenSSL Documentation</li> </ul>"},{"location":"sap-rfc-python-container/","title":"Installation Steps for <code>pyrfc</code> Module (if doing from scratch)","text":""},{"location":"sap-rfc-python-container/#step-1-download-netweaver-rfc-sdk","title":"Step 1: Download NetWeaver RFC SDK","text":"<ol> <li>Download the latest NetWeaver RFC SDK from the SAP website.</li> <li>Include the downloaded file (<code>nwrfc750P_14-70002752.zip</code>) in your repository under the <code>assets</code> folder.</li> </ol>"},{"location":"sap-rfc-python-container/#step-2-create-directory-for-sap-sdk","title":"Step 2: Create Directory for SAP SDK","text":"<pre><code>sudo mkdir -p /usr/local/sap/\n</code></pre>"},{"location":"sap-rfc-python-container/#step-3-copy-the-sdk-folder","title":"Step 3: Copy the SDK Folder","text":"<ol> <li>Extract the nwrfcsdk folder from the ZIP file.</li> <li>Copy the nwrfcsdk folder to /usr/local/sap/ folder</li> </ol>"},{"location":"sap-rfc-python-container/#step-4-create-configuration-file","title":"Step 4: Create Configuration File","text":"<pre><code>sudo nano /etc/ld.so.conf.d/nwrfcsdk.conf\n\n# Add the following line to the file:\n/usr/local/sap/nwrfcsdk/lib\n</code></pre>"},{"location":"sap-rfc-python-container/#step-5-update-library-cache-and-set-environment-variable","title":"Step 5: Update Library Cache and set Environment Variable","text":"<pre><code>sudo ldconfig\n# Verify the path configuration should not have any error(s)\nldconfig -p | grep sap\n# Set Environment Variable\nexport SAPNWRFC_HOME=/usr/local/sap/nwrfcsdk\n</code></pre>"},{"location":"sap-rfc-python-container/#step-6-install-cython-and-build-essentials","title":"Step 6: Install Cython and Build Essentials","text":"<pre><code>pip install Cython\nsudo apt-get update\nsudo apt-get install -y build-essential python3-dev\n</code></pre>"},{"location":"sap-rfc-python-container/#step-7-build-and-install-pyrfc","title":"Step 7: Build and Install pyrfc","text":"<pre><code>git clone https://github.com/SAP/PyRFC.git\ncd PyRFC\npython -m pip install --upgrade build\nPYRFC_BUILD_CYTHON=yes python -m build --wheel --sdist --outdir dist\npip install --upgrade --no-index --find-links=dist pyrfc\n</code></pre>"}]}