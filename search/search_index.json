{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to My Blog","text":""},{"location":"#azure","title":"Azure","text":"<ul> <li>Certificate Based Authentication</li> <li>Download Subscription Bill</li> <li>Download Azure Resource</li> </ul>"},{"location":"#active-directory-domain-services","title":"Active Directory Domain Services","text":"<ul> <li>Create User and assign groups</li> </ul>"},{"location":"#sap","title":"SAP","text":"<ul> <li>Setup PyRFC in your Container</li> </ul>"},{"location":"adds-user-creation/","title":"Automating Active Directory User Creation and Group Assignment","text":""},{"location":"adds-user-creation/#introduction","title":"Introduction","text":"<p>Automating user provisioning in Active Directory Domain Services (ADDS) is a common requirement for IT teams managing large organizations. Python, with its rich ecosystem of libraries, makes it possible to programmatically create users and assign them to groups in ADDS. This article provides a detailed walkthrough of a working Python implementation for creating new ADDS users and adding them to groups, using the <code>ldap3</code> library and related tools.</p>"},{"location":"adds-user-creation/#overview-of-the-workflow","title":"Overview of the Workflow","text":"<p>The core function, <code>create_new_users_adds</code>, orchestrates the process of:</p> <ol> <li>Establishing a secure connection to the ADDS server.</li> <li>Creating a new user account with the required attributes.</li> <li>Setting the user's password and enabling the account.</li> <li>Adding the user to one or more ADDS groups.</li> </ol> <p>This workflow is modular, with each step handled by a dedicated function or library call, making it easy to adapt for different environments.</p>"},{"location":"adds-user-creation/#step-1-establishing-a-connection-to-adds","title":"Step 1: Establishing a Connection to ADDS","text":"<p>The function <code>get_adds_Connection</code> uses the <code>ldap3</code> library to connect to the ADDS server over SSL. Credentials are securely retrieved (in this codebase, from Azure Key Vault, but you can use environment variables or other secure stores):</p> <pre><code>server = ldap3.Server(dc_ip, use_ssl=True)\nconn = ldap3.Connection(server, user=LDAP_USER_ID, password=LDAP_USER_PASSWORD)\nif not conn.bind():\n    print('Error in bind', conn.result)\n</code></pre> <p>This returns a connection object used for all subsequent LDAP operations.</p>"},{"location":"adds-user-creation/#step-2-creating-a-new-user-in-adds","title":"Step 2: Creating a New User in ADDS","text":"<p>The function <code>create_adds_user</code> (called within <code>create_new_users_adds</code>) performs the following:</p> <ul> <li> <p>Adds the user object: <pre><code>conn.add(\n    distinguished_name,\n    ['top', 'person', 'organizationalPerson', 'user'],\n    {\n        'givenName': first_name,\n        'sn': last_name,\n        'sAMAccountName': sam_account_name,\n        'userPrincipalName': upn_name,\n        'mail': upn_name\n    }\n)\n</code></pre>   The <code>distinguished_name</code> (DN) specifies the user's location in the directory tree (OU). For generalization, replace any organization-specific OUs with your own structure.</p> </li> <li> <p>Enables the account and sets the password: <pre><code>conn.modify(\n    distinguished_name,\n    {\n        'userAccountControl': [(ldap3.MODIFY_REPLACE, [512])],  # Enable the account\n        'unicodePwd': [(ldap3.MODIFY_REPLACE, [f'\"{default_password}\"'.encode('utf-16-le')])]\n    }\n)\n</code></pre>   The password must be encoded in UTF-16-LE and quoted. The <code>userAccountControl</code> value of 512 enables the account.</p> </li> </ul>"},{"location":"adds-user-creation/#step-3-adding-the-user-to-adds-groups","title":"Step 3: Adding the User to ADDS Groups","text":"<p>After the user is created, the code assigns them to one or more groups using the <code>add_members_to_group</code> function from <code>ldap3.extend.microsoft.addMembersToGroups</code>:</p> <p><pre><code>add_members_to_group(conn, [distinguished_name], group_dns, fix=True)\n</code></pre> - <code>conn</code>: The active LDAP connection. - <code>[distinguished_name]</code>: A list of user DNs to add. - <code>group_dns</code>: A list of group DNs (distinguished names) to which the user should be added. - <code>fix=True</code>: Ensures the function will attempt to fix any inconsistencies in group membership.</p> <p>This function performs the necessary LDAP modifications to add the user as a member of each specified group. It is robust and handles group membership updates according to Microsoft's AD schema.</p>"},{"location":"adds-user-creation/#error-handling-and-best-practices","title":"Error Handling and Best Practices","text":"<ul> <li>Error Handling: Each step is wrapped in try/except blocks, and errors are logged or emailed to administrators. This is critical for production automation.</li> <li>Security: Credentials are not hardcoded. Use secure storage for service accounts and passwords.</li> <li>Generalization: Replace any organization-specific OUs or group names with your own. The logic is portable to any ADDS environment.</li> </ul>"},{"location":"adds-user-creation/#example-creating-and-assigning-a-user","title":"Example: Creating and Assigning a User","text":"<p>Here is a simplified, generalized version of the workflow:</p> <pre><code>from ldap3 import Server, Connection, MODIFY_REPLACE\nfrom ldap3.extend.microsoft.addMembersToGroups import ad_add_members_to_groups as add_members_to_group\n\n# Connect to ADDS\nserver = Server('your_dc_ip', use_ssl=True)\nconn = Connection(server, user='your_user', password='your_password')\nconn.bind()\n\n# Create user\ndn = 'CN=John Doe,OU=Users,DC=example,DC=com'\nconn.add(dn, ['top', 'person', 'organizationalPerson', 'user'], {\n    'givenName': 'John',\n    'sn': 'Doe',\n    'sAMAccountName': 'jdoe',\n    'userPrincipalName': 'jdoe@example.com',\n    'mail': 'jdoe@example.com'\n})\n\n# Enable account and set password\nconn.modify(dn, {\n    'userAccountControl': [(MODIFY_REPLACE, [512])],\n    'unicodePwd': [(MODIFY_REPLACE, ['\"YourPassword123!\"'.encode('utf-16-le')])]\n})\n\n# Add to groups\ngroup_dns = ['CN=YourGroup,OU=Groups,DC=example,DC=com']\nadd_members_to_group(conn, [dn], group_dns, fix=True)\n\nconn.unbind()\n</code></pre>"},{"location":"adds-user-creation/#conclusion","title":"Conclusion","text":"<p>With Python and the <code>ldap3</code> library, you can fully automate the process of creating users and managing group memberships in Active Directory. This approach is scalable, secure, and adaptable to any ADDS environment. By modularizing each step and handling errors robustly, you can integrate this workflow into larger HR or IT automation pipelines.</p>"},{"location":"adds-user-creation/#references","title":"References","text":"<ul> <li>ldap3 Documentation</li> <li>Microsoft ADDS Schema</li> <li>Python ADDS Automation Examples</li> </ul>"},{"location":"azure-ad-certificate/","title":"Certificate Based Authentication","text":""},{"location":"azure-ad-certificate/#certificate-based-authentication-for-azure-ad-why-and-how","title":"Certificate-Based Authentication for Azure AD: Why and How","text":""},{"location":"azure-ad-certificate/#creating-a-certificate-for-azure-ad-authentication","title":"Creating a Certificate for Azure AD Authentication","text":"<p>To use certificate-based authentication with Azure Active Directory (Azure AD), you first need to generate a certificate. Certificates provide a secure, manageable, and standards-based way to authenticate applications. A <code>.pfx</code> certificate may be required because Azure AD expects a certificate in Personal Information Exchange (PFX) format when uploading via the portal or for certain SDKs. The <code>.pfx</code> file contains both the public and private keys, protected by a password, and is suitable for import/export scenarios.</p>"},{"location":"azure-ad-certificate/#steps-to-generate-a-certificate-using-openssl","title":"Steps to Generate a Certificate Using OpenSSL","text":"<ol> <li>Generate a Private Key: <pre><code>openssl genrsa -out my-app-auth.key 2048\n</code></pre></li> <li>Create a Certificate Signing Request (CSR): <pre><code>openssl req -new -key my-app-auth.key -out my-app-auth.csr\n</code></pre></li> <li>Generate a Self-Signed Certificate: <pre><code>openssl x509 -req -days 730 -in my-app-auth.csr -signkey my-app-auth.key -out my-app-auth.crt\n</code></pre></li> <li>Export to PFX (if needed for Azure): <pre><code>openssl pkcs12 -export -out my-app-auth.pfx -inkey my-app-auth.key -in my-app-auth.crt\n</code></pre> <p>Note: The <code>.pfx</code> format is required if you want to upload the certificate via the Azure Portal or use it with some SDKs/tools. The <code>.crt</code> file is the public certificate, and the <code>.key</code> file is your private key (keep it secure!).</p> </li> </ol>"},{"location":"azure-ad-certificate/#uploading-the-certificate-to-your-entra-azure-ad-application","title":"Uploading the Certificate to Your Entra (Azure AD) Application","text":"<ol> <li>Go to the Microsoft Entra admin center and select Azure Active Directory.</li> <li>Navigate to App registrations and select your application.</li> <li>In the left menu, click Certificates &amp; secrets.</li> <li>Under Certificates, click Upload certificate.</li> <li>Select your <code>.crt</code> or <code>.pfx</code> file and upload it.</li> <li>After uploading, Azure will display the certificate thumbprint. Save this value for use in your application code.</li> </ol>"},{"location":"azure-ad-certificate/#assigning-permissions-to-the-application","title":"Assigning Permissions to the Application","text":"<p>After uploading the certificate, you must assign the necessary API permissions to your application:</p> <ol> <li>In your application's App registration page, go to API permissions.</li> <li>Click Add a permission and select the required Microsoft APIs (e.g., Microsoft Graph, Azure Service Management, etc.).</li> <li>Choose the appropriate permission type (Application or Delegated) and select the required permissions.</li> <li>Click Add permissions.</li> <li>If required, click Grant admin consent to approve the permissions for your organization.</li> </ol> <p>Note: The application will only be able to access resources for which it has been granted permissions. Make sure to review and assign only the permissions your app needs.</p>"},{"location":"azure-ad-certificate/#why-use-a-certificate-instead-of-an-application-secret","title":"Why Use a Certificate Instead of an Application Secret?","text":""},{"location":"azure-ad-certificate/#1-security","title":"1. Security","text":"<ul> <li>Application secrets are essentially passwords. They are susceptible to accidental exposure (e.g., in code repositories, logs, or configuration files).</li> <li>Certificates use asymmetric cryptography. The private key never leaves your environment, and only the public key is uploaded to Azure AD. This makes certificates much harder to compromise.</li> </ul>"},{"location":"azure-ad-certificate/#2-lifecycle-management","title":"2. Lifecycle Management","text":"<ul> <li>Secrets typically expire every 6-12 months, requiring regular rotation and updates in all dependent systems.</li> <li>Certificates can have longer lifespans (e.g., 1-2 years), and their expiration is easier to track and automate.</li> </ul>"},{"location":"azure-ad-certificate/#3-compliance-and-best-practices","title":"3. Compliance and Best Practices","text":"<ul> <li>Microsoft and most security frameworks recommend certificates for service-to-service authentication.</li> <li>Certificates support better auditing and can be managed centrally (e.g., via Azure Key Vault).</li> </ul>"},{"location":"azure-ad-certificate/#why-use-the-msal-library-and-not-a-specific-azure-sdk","title":"Why Use the MSAL Library (and Not a Specific Azure SDK)?","text":"<p>The MSAL (Microsoft Authentication Library) for Python is a lightweight, flexible library for acquiring tokens from Azure AD. It supports a wide range of authentication scenarios, including certificate-based authentication for confidential clients.</p> <ul> <li>Why MSAL?</li> <li>MSAL is the official library for handling authentication and token acquisition with Azure AD.</li> <li>It is not tied to a specific Azure service, making it ideal for generic authentication scenarios.</li> <li> <p>It supports advanced scenarios like certificate-based authentication, multi-tenant apps, and more.</p> </li> <li> <p>Why Not Use a Specific Azure SDK?</p> </li> <li>Some Azure SDKs (e.g., for Storage, Key Vault, etc.) provide their own authentication mechanisms, but they may not support all advanced scenarios or may require additional dependencies.</li> <li>Using MSAL directly gives you full control over the authentication flow and token management, and is more transparent for troubleshooting and customization.</li> </ul>"},{"location":"azure-ad-certificate/#code-example-certificate-based-authentication-in-python","title":"Code Example: Certificate-Based Authentication in Python","text":"<p>Below is the function used in this project to acquire an Azure AD access token using a certificate:</p> <pre><code>from msal import ConfidentialClientApplication\n\ndef get_access_token_from_azure(client_id, authority, tenant_id, resource_scopes):\n    \"\"\"\n    Retrieves an access token from Azure Active Directory using a confidential client application.\n    This function uses certificate-based authentication to acquire an access token for the specified resource.\n    \"\"\"\n    try:\n        with open(f\"certs/{PFX_CERTIFICATE_NAME}.key\", \"r\") as key_file:\n            private_key = key_file.read()\n\n        app = ConfidentialClientApplication(\n            client_id=client_id,\n            authority=f\"{authority}{tenant_id}\",\n            client_credential={\n                \"thumbprint\": PFX_CERTIFICATE_NAME_TP,\n                \"private_key\": private_key,\n            },\n        )\n\n        result = app.acquire_token_for_client(scopes=resource_scopes)\n        if \"access_token\" in result:\n            return result[\"access_token\"]\n\n    except Exception as exception:\n        handle_global_exception(sys._getframe().f_code.co_name, exception)\n    finally:\n        pass\n</code></pre>"},{"location":"azure-ad-certificate/#key-points","title":"Key Points:","text":"<ul> <li>The private key is read from a secure file (<code>certs/*.key</code>).</li> <li>The certificate thumbprint and private key are passed to MSAL's <code>ConfidentialClientApplication</code>.</li> <li>No secrets or passwords are stored in code or configuration.</li> </ul>"},{"location":"azure-ad-certificate/#conclusion","title":"Conclusion","text":"<p>Certificate-based authentication is the recommended and most secure way to authenticate service applications with Azure AD. It reduces risk, simplifies management, and aligns with industry best practices. Migrating from secrets to certificates is straightforward and well-supported by both Azure and the MSAL Python library.</p>"},{"location":"azure-ad-certificate/#references","title":"References","text":"<ul> <li>MSAL Python Certificate Auth Sample</li> <li>Azure AD App Registration: Certificates &amp; Secrets</li> <li>OpenSSL Documentation</li> </ul>"},{"location":"azure-billing/","title":"Download Azure Bill","text":""},{"location":"azure-billing/#programmatically-downloading-and-storing-azure-billing-data","title":"Programmatically Downloading and Storing Azure Billing Data:","text":""},{"location":"azure-billing/#introduction","title":"Introduction","text":"<p>Automating the retrieval and storage of Azure billing data is essential for organizations seeking cost transparency and operational efficiency. This guide details a robust, production-grade approach to programmatically obtaining Azure billing data using Python, authenticating securely with certificates, and efficiently storing the results in a SQL Server database. </p>"},{"location":"azure-billing/#1-secure-authentication-acquiring-an-azure-access-token-with-certificates","title":"1. Secure Authentication: Acquiring an Azure Access Token with Certificates","text":"<p>The first step is to authenticate with Azure Active Directory (Azure AD) using certificate-based authentication. This is more secure than using client secrets and is recommended for automation and service-to-service scenarios. For a deep dive into certificate-based authentication setup, see the dedicated article: Certificate Based Authorization for Azure AD.</p> <p>Python Example:</p> <pre><code>from msal import ConfidentialClientApplication\n\ndef get_access_token(client_id, authority, tenant_id, resource_scopes, cert_thumbprint, cert_key_path):\n    \"\"\"\n    Acquire an Azure AD access token using certificate-based authentication.\n    \"\"\"\n    with open(cert_key_path, \"r\") as key_file:\n        private_key = key_file.read()\n    app = ConfidentialClientApplication(\n        client_id=client_id,\n        authority=f\"{authority}{tenant_id}\",\n        client_credential={\n            \"thumbprint\": cert_thumbprint,\n            \"private_key\": private_key,\n        },\n    )\n    result = app.acquire_token_for_client(scopes=resource_scopes)\n    if \"access_token\" not in result:\n        raise Exception(f\"Token acquisition failed: {result}\")\n    return result[\"access_token\"]\n</code></pre> <ul> <li>Why certificates? They are more secure, support longer lifecycles, and are recommended for automation.</li> <li>MSAL Library: The Microsoft Authentication Library (MSAL) is used for token acquisition, providing flexibility and support for advanced scenarios.</li> </ul>"},{"location":"azure-billing/#2-generating-the-azure-cost-report-via-rest-api","title":"2. Generating the Azure Cost Report via REST API","text":"<p>Once authenticated, you can use the Azure Cost Management API to request a cost details report for your subscription. This involves making a POST request to the appropriate endpoint and polling until the report is ready.</p> <p>Python Example:</p> <pre><code>import requests\nimport time\nimport json\n\ndef generate_azure_cost_report(subscription_id, access_token, start_date, end_date, api_version=\"2022-05-01\"):\n    url = f\"https://management.azure.com/subscriptions/{subscription_id}/providers/Microsoft.CostManagement/generateCostDetailsReport?api-version={api_version}\"\n    payload = json.dumps({\"metric\": \"ActualCost\", \"timePeriod\": {\"start\": start_date, \"end\": end_date}})\n    headers = {'Authorization': f'Bearer {access_token}', 'Content-Type': 'application/json'}\n    response = requests.post(url, headers=headers, data=payload)\n    # Poll until the report is ready\n    while response.status_code == 202:\n        location_url = response.headers.get('Location')\n        retry_after = int(response.headers.get('Retry-After', 30))\n        time.sleep(retry_after)\n        response = requests.get(url=location_url, headers=headers)\n    if response.status_code != 200:\n        raise Exception(f\"Failed to generate cost report: {response.status_code} - {response.text}\")\n    return response.json()\n</code></pre> <ul> <li>Polling: The API may return a 202 status, indicating the report is being generated. Poll the <code>Location</code> header until a 200 response is received.</li> <li>Error Handling: Always check for non-200 responses and handle errors appropriately.</li> </ul>"},{"location":"azure-billing/#3-downloading-the-cost-report-data","title":"3. Downloading the Cost Report Data","text":"<p>The response from the cost report API includes a manifest with one or more blob URLs. Download these blobs to obtain the actual cost data, typically in CSV format.</p> <p>Python Example:</p> <pre><code>import urllib3\n\ndef download_cost_report_blobs(manifest, output_path):\n    http = urllib3.PoolManager()\n    for blob in manifest['blobs']:\n        blob_url = blob['blobLink']\n        with open(output_path, 'wb') as out_file:\n            blob_response = http.request('GET', blob_url, preload_content=False)\n            out_file.write(blob_response.data)\n</code></pre> <ul> <li>Blob Download: Use a robust HTTP client (e.g., <code>urllib3</code>) to download the report data.</li> <li>Output: Save the CSV file to a secure, accessible location for further processing.</li> </ul>"},{"location":"azure-billing/#4-loading-the-cost-data-into-sql-server-efficiently","title":"4. Loading the Cost Data into SQL Server Efficiently","text":"<p>After downloading the cost report, the next step is to load the data into a SQL Server table. For large datasets, use a fast, batch insert method to optimize performance.</p> <p>Python Example:</p> <pre><code>import pyodbc\nimport csv\n\ndef load_csv_to_sql_server(csv_path, connection_string, table_name):\n    conn = pyodbc.connect(connection_string)\n    cursor = conn.cursor()\n    with open(csv_path, 'r', encoding='utf-8-sig') as csvfile:\n        reader = csv.reader(csvfile)\n        columns = next(reader)  # Header row\n        insert_query = f\"INSERT INTO {table_name} ({', '.join(columns)}) VALUES ({', '.join(['?' for _ in columns])})\"\n        data = list(reader)\n        cursor.fast_executemany = True\n        cursor.executemany(insert_query, data)\n        conn.commit()\n    cursor.close()\n    conn.close()\n</code></pre> <ul> <li>Fast Insert: The <code>fast_executemany</code> flag in <code>pyodbc</code> enables high-performance bulk inserts.</li> <li>Schema Alignment: Ensure the CSV columns match the SQL table schema.</li> </ul>"},{"location":"azure-billing/#5-orchestrating-the-end-to-end-process","title":"5. Orchestrating the End-to-End Process","text":"<p>A typical workflow to automate Azure billing data retrieval and storage:</p> <pre><code>def fetch_and_update_azure_billing_data():\n    # Step 1: Get access token\n    access_token = get_access_token(\n        client_id=..., authority=..., tenant_id=..., resource_scopes=..., cert_thumbprint=..., cert_key_path=...\n    )\n    # Step 2: Generate cost report\n    report = generate_azure_cost_report(\n        subscription_id=..., access_token=access_token, start_date=..., end_date=...\n    )\n    # Step 3: Download report blob(s)\n    download_cost_report_blobs(report['manifest'], output_path=\"azure_billing.csv\")\n    # Step 4: Load into SQL Server\n    load_csv_to_sql_server(\n        csv_path=\"azure_billing.csv\", connection_string=..., table_name=\"AzureBilling\"\n    )\n</code></pre>"},{"location":"azure-billing/#6-additional-considerations","title":"6. Additional Considerations","text":"<ul> <li>Permissions: The Azure AD application must have the required API permissions (e.g., Cost Management Reader) and access to the subscription.</li> <li>Certificate Security: Store private keys securely and never commit them to source control.</li> <li>Error Handling: Implement robust error handling and logging for production use.</li> <li>Scheduling: Use a scheduler (e.g., cron, Azure Automation) to run the process regularly.</li> </ul>"},{"location":"azure-billing/#conclusion","title":"Conclusion","text":"<p>By following this approach, you can securely and efficiently automate the retrieval and storage of Azure billing data using Python. This enables advanced reporting, cost analysis, and integration with enterprise data platforms.</p>"},{"location":"azure-billing/#references","title":"References","text":"<ul> <li>Azure Cost Management REST API</li> <li>MSAL Python Library</li> <li>pyodbc Documentation</li> <li>Azure AD App Registration: Certificates &amp; Secrets</li> </ul>"},{"location":"azure-resources/","title":"Download Azure Resource","text":""},{"location":"azure-resources/#programmatically-downloading-azure-resource-inventory-and-tag-management","title":"Programmatically Downloading Azure Resource Inventory and Tag Management","text":""},{"location":"azure-resources/#introduction","title":"Introduction","text":"<p>Maintaining an up-to-date inventory of Azure resources and their associated tags is critical for governance, cost management, and compliance. This article provides a detailed, production-grade approach to programmatically fetching Azure resource metadata and synchronizing it with a SQL Server database using Python. </p>"},{"location":"azure-resources/#1-authentication-secure-access-to-azure-apis","title":"1. Authentication: Secure Access to Azure APIs","text":"<p>Before accessing Azure resources, authenticate using a secure method. The function below demonstrates using the Azure Identity SDK's <code>ClientSecretCredential</code> for authentication. This is a common approach for automation scenarios, but for higher security, certificate-based authentication is recommended (see other article Certificate Based Authorization for Azure AD.)</p>"},{"location":"azure-resources/#deep-dive-get_azure_credential-function","title":"Deep Dive: <code>get_azure_credential</code> Function","text":"<p>The <code>get_azure_credential</code> function leverages the <code>azure-identity</code> Python SDK, which provides a unified way to authenticate to Azure services. Here, we use the <code>ClientSecretCredential</code> class, which is suitable for service principals (app registrations) with a client secret.</p> <p>Python Example:</p> <pre><code>from azure.identity import ClientSecretCredential\n\ndef get_azure_credential(tenant_id, client_id, client_secret):\n    \"\"\"\n    Returns a credential object for authenticating with Azure SDKs.\n    Uses the azure-identity library's ClientSecretCredential.\n    \"\"\"\n    return ClientSecretCredential(\n        tenant_id=tenant_id,\n        client_id=client_id,\n        client_secret=client_secret\n    )\n</code></pre> <ul> <li>azure-identity SDK: This is the official Microsoft library for Azure authentication in Python. It supports multiple credential types, including secrets, certificates, managed identity, and interactive login.</li> <li>ClientSecretCredential: This class is used for service-to-service authentication using a client ID and secret. It is widely supported by Azure SDKs, including resource management, storage, and more.</li> <li>When to use: Use this for automation where a client secret is securely stored (e.g., in Azure Key Vault or environment variables). For higher security, use <code>CertificateCredential</code> instead.</li> </ul>"},{"location":"azure-resources/#2-fetching-azure-resource-inventory","title":"2. Fetching Azure Resource Inventory","text":"<p>Use the Azure SDK to enumerate all resources in a subscription. Extract key metadata such as resource ID, name, location, type, and tags.</p> <p>Python Example:</p> <pre><code>def fetch_azure_resources(credential, subscription_id):\n    client = ResourceManagementClient(credential, subscription_id)\n    resource_list = []\n    for item in client.resources.list():\n        type_parts = str(item.type).split('/')\n        type1, type2, type3, type4, type5 = (type_parts + [''] * 5)[:5]\n        resource_group_list = str(item.id).split('/')\n        resource_data = {\n            \"id\": str(item.id).replace(f'/subscriptions/{subscription_id}/', ''),\n            \"location\": item.location,\n            \"name\": item.name,\n            \"tags\": item.tags,\n            \"resourceGroup\": resource_group_list[4] if len(resource_group_list) &gt;= 4 else '',\n            \"type1\": type1,\n            \"type2\": type2,\n            \"type3\": type3,\n            \"type4\": type4,\n            \"type5\": type5,\n        }\n        resource_list.append(resource_data)\n    return resource_list\n</code></pre> <ul> <li>Resource Types: The code splits the resource type string to extract up to five type levels for flexible reporting.</li> <li>Tags: Tags are included for governance and cost allocation.</li> </ul>"},{"location":"azure-resources/#3-synchronizing-with-sql-server-fast-bulk-operations","title":"3. Synchronizing with SQL Server: Fast Bulk Operations","text":"<p>Efficiently update the SQL Server inventory table by marking all resources as inactive, then bulk updating existing resources and inserting new ones. This ensures the database reflects the current Azure state.</p> <p>Note: The <code>Dim_Resources</code> table is not a full load (truncate-and-reload) table. Instead, it is designed to retain records of resources that may have been deleted from Azure. By marking resources as inactive rather than removing them, you can track the lifecycle of resources, including those that have been deleted, for audit, compliance, and historical analysis purposes.</p> <p>Python Example:</p> <pre><code>import pyodbc\n\ndef sync_resources_to_sql(resource_list, connection_string):\n    conn = pyodbc.connect(connection_string)\n    cursor = conn.cursor()\n    existing_resource_ids = {str(row[0]).lower() for row in cursor.execute(\"SELECT ResourceID FROM Dim_Resources\").fetchall()}\n    updateresources = [\n        [r['location'], r['name'], r['resourceGroup'], r['type1'], r['type2'], r['type3'], r['type4'], r['type5'], True, r['id']]\n        for r in resource_list if str(r['id']).lower() in existing_resource_ids\n    ]\n    newresources = [\n        [r['id'], r['location'], r['name'], r['resourceGroup'], r['type1'], r['type2'], r['type3'], r['type4'], r['type5'], True]\n        for r in resource_list if str(r['id']).lower() not in existing_resource_ids\n    ]\n    cursor.execute('UPDATE Dim_Resources SET Active = 0')\n    if updateresources:\n        query = '''UPDATE Dim_Resources SET Location=?, Name=?, ResourceGroup=?, Type1=?, Type2=?, Type3=?, Type4=?, Type5=?, Active=? WHERE ResourceId=?'''\n        cursor.fast_executemany = True\n        cursor.executemany(query, updateresources)\n    if newresources:\n        query = '''INSERT INTO Dim_Resources (ResourceID, Location, Name, ResourceGroup, Type1, Type2, Type3, Type4, Type5, Active) VALUES (?,?,?,?,?,?,?,?,?,?)'''\n        cursor.fast_executemany = True\n        cursor.executemany(query, newresources)\n    conn.commit()\n    cursor.close()\n    conn.close()\n</code></pre> <ul> <li>Bulk Operations: Use <code>fast_executemany</code> for high-performance updates and inserts.</li> <li>Active Flag: Mark all resources as inactive before updating, then set active for current resources.</li> </ul>"},{"location":"azure-resources/#4-end-to-end-orchestration","title":"4. End-to-End Orchestration","text":"<p>A typical workflow for resource inventory management:</p> <pre><code>def fetch_and_store_resources():\n    credential = get_azure_credential(tenant_id=..., client_id=..., client_secret=...)\n    resource_list = fetch_azure_resources(credential, subscription_id=...)\n    sync_resources_to_sql(resource_list, connection_string=...)\n</code></pre>"},{"location":"azure-resources/#5-best-practices-and-considerations","title":"5. Best Practices and Considerations","text":"<ul> <li>Security: Use certificate-based authentication for automation when possible. Store credentials securely.</li> <li>Performance: Use bulk operations for large datasets.</li> <li>Data Quality: Regularly update the inventory to reflect the current Azure state.</li> <li>Scheduling: Automate the process with a scheduler (e.g., cron, Azure Automation).</li> <li>Auditing: Keep logs of changes and exceptions for compliance.</li> </ul>"},{"location":"azure-resources/#conclusion","title":"Conclusion","text":"<p>By following this approach, you can automate the discovery and inventory of Azure resources, ensuring your SQL Server database remains a reliable source of truth for governance and reporting.</p>"},{"location":"azure-resources/#references","title":"References","text":"<ul> <li>Azure Resource Management Python SDK</li> <li>azure-identity Python SDK</li> <li>pyodbc Documentation</li> <li>Azure Tagging Best Practices</li> </ul>"},{"location":"sap-rfc-python-container/","title":"Installing the <code>PyRFC</code> Module for SAP Integration: A Step-by-Step Guide","text":"<p>Integrating Python with SAP systems using the <code>PyRFC</code> module can unlock powerful automation and data access capabilities. This article provides a clear, professional walkthrough for setting up the SAP NetWeaver RFC SDK and building the <code>PyRFC</code> Python package from scratch.</p>"},{"location":"sap-rfc-python-container/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to the SAP NetWeaver RFC SDK (download from the official SAP website)</li> <li>Basic familiarity with Linux command line</li> <li>Python 3.x and administrative privileges on your system</li> </ul>"},{"location":"sap-rfc-python-container/#1-download-the-netweaver-rfc-sdk","title":"1. Download the NetWeaver RFC SDK","text":"<ul> <li>Download the latest NetWeaver RFC SDK from the SAP website.</li> <li>Place the downloaded file (<code>nwrfc750P_14-70002752.zip</code>) in your repository's <code>assets</code> folder for easy access.</li> </ul>"},{"location":"sap-rfc-python-container/#2-prepare-the-sap-sdk-directory","title":"2. Prepare the SAP SDK Directory","text":"<p>Create the target directory for the SAP SDK:</p> <pre><code>sudo mkdir -p /usr/local/sap/\n</code></pre>"},{"location":"sap-rfc-python-container/#3-extract-and-copy-the-sdk","title":"3. Extract and Copy the SDK","text":"<ul> <li>Extract the <code>nwrfcsdk</code> folder from the ZIP file.</li> <li>Copy the extracted <code>nwrfcsdk</code> folder to <code>/usr/local/sap/</code>.</li> </ul>"},{"location":"sap-rfc-python-container/#4-configure-the-library-path","title":"4. Configure the Library Path","text":"<p>Create a configuration file for the dynamic linker and add the SDK library path:</p> <pre><code>sudo nano /etc/ld.so.conf.d/nwrfcsdk.conf\n\n# Add the following line to the file:\n/usr/local/sap/nwrfcsdk/lib\n</code></pre>"},{"location":"sap-rfc-python-container/#5-update-the-library-cache-and-set-environment-variable","title":"5. Update the Library Cache and Set Environment Variable","text":"<p>Update the system's library cache and set the required environment variable:</p> <pre><code>sudo ldconfig\n# Verify the path configuration should not have any error(s)\nldconfig -p | grep sap\n# Set Environment Variable\nexport SAPNWRFC_HOME=/usr/local/sap/nwrfcsdk\n</code></pre>"},{"location":"sap-rfc-python-container/#6-install-cython-and-build-essentials","title":"6. Install Cython and Build Essentials","text":"<p>Install the necessary build tools and Python dependencies:</p> <pre><code>pip install Cython\nsudo apt-get update\nsudo apt-get install -y build-essential python3-dev\n</code></pre>"},{"location":"sap-rfc-python-container/#7-build-and-install-pyrfc","title":"7. Build and Install <code>pyrfc</code>","text":"<p>Clone the PyRFC repository and build the package:</p> <pre><code>git clone https://github.com/SAP/PyRFC.git\ncd PyRFC\npython -m pip install --upgrade build\nPYRFC_BUILD_CYTHON=yes python -m build --wheel --sdist --outdir dist\npip install --upgrade --no-index --find-links=dist pyrfc\n</code></pre> <p>Pro Tip: Double-check all paths and environment variables before building. For troubleshooting, consult the PyRFC documentation or reach out to the SAP community forums.</p> <p>By following these steps, you\u2019ll have a working Python-to-SAP integration environment using the <code>pyrfc</code> module. Happy coding!</p>"}]}